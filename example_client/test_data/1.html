<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<title>
    Object Computing, Inc. &mdash; Java News Brief &mdash;
                June&nbsp;2009</title>
        <style type="text/css">
            body {
                color: rgb(0, 0, 0);
                background-color: rgb(255, 255, 255);
                font-family: Verdana, sans-serif;
                margin-left: 0.25in;
                margin-right: 0.25in;
            }
            a.career {
                font-weight: bold;
            }
            a:hover {
                color: rgb(0, 0, 255);
                background-color: rgb(255, 253, 160);
            }
            code {
                font-family: "Courier New", monospace;
            }
            div.center {
                text-align: center;
            }
            h1 {
                text-align: center;
            }
            h2 {
                text-align: left;
            }
            h3 {
                text-align: left;
            }
            h4 {
                text-align: left;
            }
            h5 {
                text-align: left;
            }
            hr {
                height: 1px;
                color: rgb(0, 0, 0);
                background-color: transparent;
            }
            hr.January {
                height: 1px;
                color: rgb(147, 146, 143);
                background-color: transparent;
            }
            hr.February {
                height: 1px;
                color: rgb(72, 94, 180);
                background-color: transparent;
            }
            hr.March {
                height: 1px;
                color: rgb(122, 96, 86);
                background-color: transparent;
            }
            hr.April {
                height: 1px;
                color: rgb(121, 159, 214);
                background-color: transparent;
            }
            hr.May {
                height: 1px;
                color: rgb(147, 120, 95);
                background-color: transparent;
            }
            hr.June {
                height: 1px;
                color: rgb(131, 142, 222);
                background-color: transparent;
            }
            hr.July {
                height: 1px;
                color: rgb(167, 79, 120);
                background-color: transparent;
            }
            hr.August {
                height: 1px;
                color: rgb(81, 119, 156);
                background-color: transparent;
            }
            hr.September {
                height: 1px;
                color: rgb(17, 59, 86);
                background-color: transparent;
            }
            hr.October {
                height: 1px;
                color: rgb(78, 86, 44);
                background-color: transparent;
            }
            hr.November {
                height: 1px;
                color: rgb(212, 130, 66);
                background-color: transparent;
            }
            hr.December {
                height: 1px;
                color: rgb(167, 47, 81);
                background-color: transparent;
            }
            kbd {
                font-family: "Courier New", monospace;
            }
            p {
                text-align: justify;
            }
            p.author {
                text-align: center;
            }
            p.footer {
                text-align: justify;
            }
            pre {
                font-family: "Courier New", monospace;
            }
            .educationquicklinks {
                text-align: center;
            }
            .quicklinks {
                text-align: right;
            }
            .red {
                color: rgb(255, 0, 0);
                background-color: rgb(255, 255, 255);
            }
            .green {
                color: rgb(0, 128, 0);
                background-color: rgb(255, 255, 255);
            }
            .blue {
                color: rgb(0, 0, 192);
                background-color: rgb(255, 255, 255);
            }
            .code {
                background-color: #FFFFF0;
                border: dashed black 1px;
                padding-left: 10px;
            }
            .comment {
                color: rgb(128,128,128);
                font-weight: normal;
                font-style: italic;
            }
            .centered {
                margin-left: auto;
                margin-right: auto;
            }
            .rowheader {
                background-color: lightblue;
                font-weight: bold
            }
			table.data
			{
				border:1px solid black;
				border-collapse:collapse;
			}
			table.data th
			{
				background-color:lightblue;
				border:1px solid black;
				padding:3px;
			}
			table.data td
			{
				border:1px solid black;
				padding:3px;
			}        
</style>
</head>
<body>
<a name="top"/>

<div class="quicklinks">
<a href="http://www.ociweb.com">Home</a> |
            <a href="http://www.ociweb.com/jnb/index.html">Java News Brief Archive</a> |
            <a href="#ocieducationalservices">OCI Educational Services</a>
</div>
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr>
<td>
<img moz-do-not-send="true" alt="" src="http://www.ociweb.com/jnb/images/OCILogo.png" width="180" height="120"/>
</td>
<td>
<img moz-do-not-send="true" alt="" src="http://www.ociweb.com/jnb/images/JuneJavaNewsBriefLeft.png" width="10" height="58"/>
</td>
<td width="100%">
<img moz-do-not-send="true" alt="" src="http://www.ociweb.com/jnb/images/JuneJavaNewsBriefMiddle.png" width="100%" height="58"/>
</td>
<td>
<img moz-do-not-send="true" alt="" src="http://www.ociweb.com/jnb/images/JuneJavaNewsBriefRight.png" width="278" height="58"/>
</td>
</tr>
</table>
<div>
<hr class="June"/>
<img moz-do-not-send="true" alt="" src="http://www.ociweb.com/jnb/images/JuneTechnicalInsightoftheMonth.png" width="377" height="34"/>
<br/>
<br/>
</div>

        <h1>Apache Thrift</h1>
        <p class="author">
            by<br/>

            Andrew Prunicki, Senior Software Engineer
            <br/>Object Computing, Inc. (OCI)
        </p>

        <h2>Introduction</h2>
        <p>
            <a href="http://incubator.apache.org/thrift" shape="rect">Thrift</a>
            is a framework for creating interoperable and scalable
            services.  Thrift was originally developed at Facebook, and contributed
            to Apache in order to foster greater use.  Thrift is released under
            the Apache 2.0 license.
        </p>
        <p>
            Through a simple and straight-forward
            <a href="http://en.wikipedia.org/wiki/Interface_definition_language" shape="rect">Interface Definition Language</a>
            (IDL), Thrift allows you to define and create services that are both
            consumable by and serviceable by numerous languages.  Using code
            generation, Thrift creates a set of files that can then be used to
            create clients and/or servers.  In addition to interoperability,
            Thrift can be very efficient through a unique serialization
            mechanism that is efficient in both time and space.
        </p>
        <p>
            The choice of programming language at Facebook is based on what
            language is best suited for the task at hand.  While pragmatic, this
            flexibility resulted in some difficulties when these applications
            needed to call one another.  After analysis, Facebook's engineers
            did not find anything currently existing that met their needs of
            interoperability, transport efficiency, and simplicity (amongst others).
            Out of this need, Facebook's engineers developed efficient protocols
            and a services infrastructure that became Thrift.  Facebook now uses
            Thrift for their back-end services - the reason for which it was
            designed.
        </p>
        <p>
            This article is structured in the following topics:
        </p>
        <ul>
            <li>
<a href="#arch" shape="rect">Thrift Architecture</a>
</li>
            <li>
<a href="#protocols" shape="rect">Supported Protocols, Transports and Servers</a>
</li>
            <li>
<a href="#create" shape="rect">Creating a Thrift Service</a>
</li>
            <li>
<a href="#compare" shape="rect">Comparing Thrift</a>
</li>
            <li>
<a href="#conclusion" shape="rect">Conclusion</a>
</li>
        </ul>
        <h2 id="arch">Thrift Architecture</h2>
        <p>
            Thrift includes a complete stack for creating clients and servers.
            The diagram below depicts the Thrift stack.
        </p>
        <table width="100%">
<tr>
<td align="center" colspan="1" rowspan="1">
            <img moz-do-not-send="true" src="http://www.ociweb.com/jnb/jnbJun2009_stack.png" alt="Thrift Stack"/>
        </td>
</tr>
</table>
        <p>
            The top portion of the stack is generated code from
            your Thrift definition file.  Thrift services result in generated
            client and processor code.  These are represented by the brown boxes
            in the diagram.  The data structures that are sent (other than
            built-in types) also result in generated code.  These result in the
            red boxes.  The protocol and transport are part of the Thrift runtime
            library.  Therefore with Thrift, you can define a service, and are
            free to change the protocol and transport without re-generating your
            code.
        </p>
        <p>
            Thrift also includes a server infrastructure to tie the protocols and
            transports together.  There are blocking, non-blocking, single and
            multithreaded servers available.
        </p>
        <p>
            The "Underlying I/O" portion of the stack differs based on the
            language in question.  For Java and Python network I/O, the built-in
            libraries are leveraged by the Thrift library, while the C++
            implementation uses its own custom implementation.
        </p>
	<p>
	</p>
        <h2 id="protocols">Supported Protocols, Transports and Servers.</h2>
        <p>
            Thrift allows you to choose independently between your protocol,
            transport and server.  With Thrift being originally developed in C++,
            Thrift has the greatest variation among these in the C++ implementation.
        </p>
        <p>
            Thrift supports both text and binary protocols.  The binary protocols
            outperform the text protocols, but there are times when the text
            protocols may be useful (such as in debugging).  Some of the protocols
            Thrift supports:
        </p>
        <ul>
            <li>TBinaryProtocol - A straight-forward binary format encoding
            numeric values as binary, rather than converting to text.</li>
            <li>TCompactProtocol - Very efficient, dense encoding of data (See
            details below).</li>
            <li>TDenseProtocol - Similar to TCompactProtocol but strips off the
            meta information from what is transmitted, and adds it back in at
            the receiver.  TDenseProtocol is still experimental and not yet
            available in the Java implementation.</li>
            <li>TJSONProtocol - Uses JSON for encoding of data.</li>
            <li>TSimpleJSONProtocol - A write-only protocol using JSON.  Suitable
            for parsing by scripting languages</li>
            <li>TDebugProtocol - Uses a human-readable text format to aid in
            debugging.</li>
        </ul>
        <p>
            While the above protocols describe "what" is transmitted, Thrift's
            transports are the "how".  Here are a number of transports that
            Thrift supports:
        </p>
        <ul>
            <li>TSocket - Uses blocking socket I/O for transport.</li>
            <li>TFramedTransport - Sends data in frames, where each frame is
            preceded by a length.  This transport is required when using a
            non-blocking server.</li>
            <li>TFileTransport - This transport writes to a file.  While this
            transport is not included with the Java implementation, it should
            be simple enough to implement.
            </li>
            <li>TMemoryTransport - Uses memory for I/O.  The Java implementation
            uses a simple ByteArrayOutputStream internally.</li>
            <li>TZlibTransport - Performs compression using
            <a href="http://zlib.net/" shape="rect">zlib</a>.  Used in conjunction with
            another transport.  Not available in the Java implementation.</li>
        </ul>
        <p>
            Lastly, Thrift provides a number of servers:
        </p>
        <ul>
            <li>TSimpleServer - A single-threaded server using std blocking io.
            Useful for testing.</li>
            <li>TThreadPoolServer - A multi-threaded server using std blocking
            io.</li>
            <li>TNonblockingServer - A multi-threaded server using non-blocking
            io (Java implementation uses NIO channels).  TFramedTransport must be
            used with this server.</li>
        </ul>
        <p>
            Thrift allows only one service per server.  Although this is
            certainly a limitation, this can be accommodated through a work-around.
            By defining a composite service that extends all of the other services
            that a given server should process, a single server can thus accommodate
            multiple services.  If this work-around is insufficient for your needs,
            you can always create multiple servers.  This scenario would mean
            however you would be using more resources than necessary (ports,
            memory, etc.).
        </p>
        <h3>TCompactProtocol</h3>
        <p>
            Given that the TCompactProtocol is the most-efficient method in
            the Java implement of Thrift and the example used throughout this
            article, some further explanation of the protocol is warranted.
            This protocol writes numeric tags for each piece of data.  The
            recipient is expected to properly match these tags with the data.
            If the data is not present, there simply is no tag/data pair.
        </p>
        <table width="100%">
<tr>
<td align="center" colspan="1" rowspan="1">
            <img moz-do-not-send="true" src="http://www.ociweb.com/jnb/jnbJun2009_compact_data_fmt.png" alt="Compact Data Format"/>
        </td>
</tr>
</table>
        <p>
            For integers, the TCompactProtocol performs compression using
            <a href="http://en.wikipedia.org/wiki/Variable_length_unsigned_integer" shape="rect">Variable-Length Quantity</a>
            (VLQ) encoding from the MIDI file format.
            VLQ is a relatively simple format that uses 7 of 8 bits out of each
            byte for information, with the 8th bit used as a continuation bit.
            VLQ's worst-case encoding is acceptable.  For a 32bit int, it is 5
            bytes.  For 64 bit ints, it is 10 bytes.  The diagram below shows
            how the decimal value 106903 (0x1A197) is represented in VLQ, saving
            1 byte if it was stored in 32 bits:
        </p>
        <table width="100%">
<tr>
<td align="center" colspan="1" rowspan="1">
            <img moz-do-not-send="true" src="http://www.ociweb.com/jnb/jnbJun2009_478px-Uintvar_coding.svg.png" alt="Variable-Length Quantity (reference: http://upload.wikimedia.org/wikipedia/en/c/c6/Uintvar_coding.svg)"/>
        </td>
</tr>
</table>
        <h2 id="create">Creating A Thrift Service</h2>
        <p>
            Creating a Thrift service first requires creating a Thrift file
            describing a service, generating the code for the service, and
            finally writing some supporting code to start the service and client
            code to call it.
        </p>
        <h3>Definition</h3>
        <p>
            A Thrift definition file should be familiar to anyone who knows
            any language with a c syntax.  Thrift files use keywords such as
            struct and int as well as curly braces for containing types and
            parenthesis for parameter lists.  Thrift allows you to transfer both
            simple and complex types.  Let's create a service for managing
            courses and students.
        </p>
        <div class="code">
            <pre xml:space="preserve">
senum PhoneType {
  "HOME",
  "WORK",
  "MOBILE"
  "OTHER"
}

struct Phone {
  1: i32    id,
  2: string number,
  3: PhoneType type
}
            </pre>
        </div>
        <p>
            Here we have a Phone which contains an id, number and type.  The
            phone number is a simple string, while the type is an enumeration
            limited to the values "HOME", "WORK", "MOBILE" and "OTHER".  Thrift
            uses the struct keyword to define a simple structure and senum for
            an enumeration.  The Java generated code will create a POJO class
            for struct as you might expect.  Disappointingly senum will not
            result in an Enum, but rather a simple Java String in the Phone class.
        </p>
        <p>
            Note the numeric identifiers preceding each element in the struct.
            These identifiers are used during serialization/deserialization to
            speed parsing and minimize the size of the metadata.  These numeric
            identifiers are what are passed over the wire rather than the string
            names of elements.
        </p>
        <div class="code">
            <pre xml:space="preserve">
struct Person {
  1: i32    id,
  2: string firstName,
  3: string lastName,
  4: string email,
  5: list&lt;Phone&gt; phones
}

struct Course {
  1: i32    id,
  2: string number,
  3: string name,
  4: Person instructor,
  5: string roomNumber,
  6: list&lt;Person&gt; students
}
            </pre>
        </div>
        <p>
            Here we have two more structs - Person and Course.  Notice that these
            structs build on one another.  The Person contains a list of Phones,
            while Course contains an instructor (one Person) and students
            (list of Persons).  Thrift supports multiple collection types - list,
            set and map.
        </p>
        <p>
            This completes the setup of our types.  Let's move on to services.
        </p>
        <div class="code">
            <pre xml:space="preserve">
service CourseService {
  list&lt;string&gt; getCourseInventory(),
  Course getCourse(1:string courseNumber) throws (1: CourseNotFound cnf),
  void addCourse(1:Course course) throws (1: UnacceptableCourse uc)
  void deleteCourse(1:string courseNumber) throws (1: CourseNotFound cnf)
}
            </pre>
        </div>
        <p>
            Here we have a defined a single service with 4 methods.  Note that
            the arguments to service methods also require ordinals, just like
            structs.  Also note that services can declare thrown exceptions and
            again each exception requires an ordinal:
        </p>
        <div class="code">
            <pre xml:space="preserve">
exception CourseNotFound {
  1: string message
}

exception UnacceptableCourse {
  1: string message
}
            </pre>
        </div>
        <p>
            Before moving on to code generation, Thrift supports namespaces.  For
            each namespace, you declare the language binding, as well as the
            namespace.  In Java, this defines the package into which the generated
            code is created.  The namespace declaration used in the example
            is below:
        </p>
        <div class="code">
            <pre xml:space="preserve">
namespace java com.ociweb.jnb.thrift.gen
namespace py com.ociweb.jnb.thrift
            </pre>
        </div>
        <p>
            This completes our Thrift file.
        </p>
        <h3>Code Generation</h3>
        <p>
            Thrift supports many languages too varying degrees.  The complete
            list is below.  Be careful  before assuming that
            just because your language has some support that it supports all of
            the features of Thrift.  Python for instance, only supports
            TBinaryProtocol.
        </p>
        <ul>
            <li>Cocoa</li>
            <li>C++</li>
            <li>C#</li>
            <li>Erlang</li>
            <li>Haskell</li>
            <li>Java</li>
            <li>OCaml</li>
            <li>Perl</li>
            <li>PHP</li>
            <li>Python</li>
            <li>Ruby</li>
            <li>Smalltalk</li>
        </ul>
        <p>
            With this being the Java News Brief, this article will focus
            on the Java side of Thrift.  Python will also be used in order to
            show how Thrift does indeed support cross-language development.  The
            sample thrift file "course.thrift" used throughout this article
            requires the following invocations to generate Java and Python
            code, respectively:
        </p>
        <ul>
            <li>thrift --gen java course.thrift</li>
            <li>thrift --gen py course.thrift</li>
        </ul>
        <p>
            The Thrift code generator is written in C++.  Before running the
            Thrift code generation tool, you will need to build
            Thrift from source.  If you don't care to bother for this article,
            simply skip this part and move on.  The sample code has all you need
            to run the Java examples.  If you decide to build it, the Thrift
            wiki has a page explaining this in sufficient detail (see
            references below).
        </p>
        <p>
            The thrift code generator produces the following files for java and
            python, respectively:
        </p>
        <div class="code">
            <pre xml:space="preserve">
|-- gen-java
|   `-- com
|       `-- ociweb
|           `-- jnb
|               `-- thrift
|                   `-- gen
|                       |-- Course.java
|                       |-- CourseNotFoundException.java
|                       |-- CourseService.java
|                       |-- Person.java
|                       |-- Phone.java
|                       `-- UnacceptableCourseException.java
`-- gen-py
    |-- __init__.py
    `-- com
        |-- __init__.py
        `-- ociweb
            |-- __init__.py
            `-- jnb
                |-- __init__.py
                `-- thrift
                    |-- CourseService-remote
                    |-- CourseService.py
                    |-- __init__.py
                    |-- constants.py
                    `-- ttypes.py
            </pre>
        </div>
        <p>
            Taking a look at the Java results, an individual file was
            created for each Thrift struct and exception, as you might expect.
            The senum thrift type did not result in a Java Enum as mentioned above,
            however.  Rather, it resulted in a simple Java String inside the
            Phone class with a comment in the validate method stating that this
            is where the values for the type should be verified.
            <a href="http://code.google.com/p/protobuf/" shape="rect">Protocol Buffers</a>
            on the other hand, did produce a Java Enum for the equivalent
            definition (see source for details).  Lastly, a CourseService.java
            file was generated.  This file contains classes to create clients
            and servers.
        </p>
        <p>
            The Python results are again what you might expect.  All the Thrift
            struct types as well as the exceptions are in the ttypes.py module,
            while the client and server code is in the CourseService.py module.
        </p>
        <h3>Creating a Java Server</h3>
        <p>
            Creating a server in Thrift requires about the same amount of code
            as the other technologies examined in this article (REST and RMI).
            Check out the example code and judge for yourself.  This example
            will use the TCompactProtocol with the FramedTransport
            and a non-blocking server.  TFramedTransport is a requirement for
            using a non-blocking server, since the frames are used to determine
            when a given request is complete.
        </p>
        <div class="code">
            <pre xml:space="preserve">
final TNonblockingServerSocket socket = new TNonblockingServerSocket(PORT);
final CourseService.Processor processor = new CourseService.Processor(
        new Handler());
final TServer server = new THsHaServer(processor, socket,
        new TFramedTransport.Factory(), new TCompactProtocol.Factory());

server.serve();

...

private static class Handler implements CourseService.Iface {

    @Override
    public List&lt;String&gt; getCourseInventory() throws
            TException {
        return db.getCourseList();
    }

    @Override
    public Course getCourse(String courseNumber) throws
            CourseNotFoundException, TException {
        final com.ociweb.jnb.thrift.db.Course dbCourse =
            db.getCourse(courseNumber);
        if (dbCourse != null) {
            return ConversionHelper.fromDbCourse(dbCourse);
        }
        
        return null;
    }
    
    @Override
    public void addCourse(Course course) throws
            UnacceptableCourseException, TException {
        com.ociweb.jnb.thrift.db.Course dbCourse =
            ConversionHelper.toDbCourse(course);
        db.addCourse(dbCourse);
    }

    @Override
    public void deleteCourse(String courseNumber) throws
            CourseNotFoundException, TException {
        if (db.getCourse(courseNumber) != null) {
            db.deleteCourse(courseNumber);
        }
    }
}
            </pre>
        </div>
        <p>
            The first few lines before the ellipsis simply setup the server with
            the protocol, transport and server type we want to use.  The handler
            class is where the implementation of the services is done.  There
            is a fictitious database referenced as "db" that is used for the calls
            to distill the code to its relevant parts and enable re-use for the
            comparisons later in this article.
        </p>
        <h3>Creating a Java Client</h3>
        <p>
            Creating a Java client requires the same basic setup as the server,
            but does not require implementation of an interface.
        </p>
        <div class="code">
            <pre xml:space="preserve">
<span class="comment">//Setup the transport and protocol</span>
final TSocket socket = new TSocket(HOST, PORT);
socket.setTimeout(SOCKET_TIMEOUT);
final TTransport transport = new TFramedTransport(socket);
final TProtocol protocol = new TCompactProtocol(transport);
final CourseService.Client client = new CourseService.Client(protocol);

<span class="comment">//The transport must be opened before you can begin using</span>
transport.open();

<span class="comment">//All hooked up, start using the service</span>
List&lt;String&gt; classInv = client.getCourseInventory();
System.out.println("Received " + classInv.size() + " class(es).");

client.deleteCourse("WINDOWS_301");

classInv = client.getCourseInventory();
System.out.println("Received " + classInv.size() + " class(es).");

transport.close();
            </pre>
        </div>
        <p>
            The first few lines are the corollary to the setup of the server.  The
            next several lines call the getCourseInventory and deleteCourse
            methods of the service.  One thing to note is that while the server
            is using non-blocking IO, the client is using blocking IO.  The
            equivalent non-blocking client socket was not fully implemented in
            the release build of Thrift that this example is built on.
            Each service operation actually calls send_&lt;service-method&gt;
            and recv_&lt;service-method&gt; method pairs internally.  I tried
            calling these methods to see if I could get asynchronous behavior
            but had little luck.  There is an "async" modifier that can be added
            to void return type methods, but the generated code looked no
            different with or without it.  Finally, the generated receive
            methods don't gracefully return if no response was received when you
            do call them.
        </p>
        <h3>Creating a Python Client</h3>
        <p>
            The Python client is effectively the same as the Java client except
            for syntax.
        </p>
        <div class="code">
            <pre xml:space="preserve">
<span class="comment">#Setup the transport and protocol</span>
socket = TSocket.TSocket("localhost", 8000)
socket._timeout = 1000
transport = TTransport.TFramedTransport(socket)
protocol_factory = TBinaryProtocol.TBinaryProtocolFactory()
protocol = protocol_factory.getProtocol(transport)
client = Client(protocol)

<span class="comment">#The transport must be opened before you can begin using</span>
transport.open()

classInv = client.getCourseInventory()
print "Received", len(classInv), "class(es)"

client.deleteCourse("WINDOWS_301")

classInv = client.getCourseInventory()
print "Received", len(classInv), "class(es)"
            </pre>
        </div>
        <p>
            Note that the Python code uses the TBinaryProtocol and not
            TCompactProtocol.  The version of Thrift used for this article
            does not support TCompactProtocol for Python.
        </p>
        <p>
            Both clients produce the following output against a newly started
            server:
        </p>
        <div class="code">
            <pre xml:space="preserve">
Received 18 class(es).
Received 17 class(es).
            </pre>
        </div>
        <h3>Running Thrift</h3>
        <p>
            For more details on running the examples, see the README included
            with the <a href="http://jnb.ociweb.com/jnb/jnbJun2009Source.zip" shape="rect">source</a>.
            For a quick start, simply run the following from the java directory:
        </p>
        <ul>
            <li>ant start.thrift.server</li>
            <li>ant run.thrift.client</li>
        </ul>
        <h2 id="compare">Comparing Thrift</h2>
        <p>
            In order to validate Thrift's value proposition, I decided to compare
            it with some other service technologies that are also fairly easy
            to use in practice.  Since
            <a href="http://java.sun.com/developer/technicalArticles/WebServices/restful/" shape="rect">RESTful</a>
            webservices seem to be popular of
            late, I have compared Thrift to REST.  Although Protocol Buffers
            does not include a services infrastructure, it transports objects in
            a similar fashion to Thrift's TCompactProtocol, thus making it a
            useful comparison.  Lastly, I included
            <a href="http://java.sun.com/javase/technologies/core/basic/rmi/index.jsp" shape="rect">RMI</a>,
            since it uses a binary
            transport and thus can serve as a "reference implementation" of
            sorts for Java binary object transport.
        </p>
        <p>
            For the comparisons, I compared the file sizes and runtime performance
            of each service technology.  For REST, I compared both XML-based and
            JSON-based REST.  For Thrift, I chose the most efficient transport
            available for Java - TCompactProtocol.
        </p>
        <h3>Size Comparison</h3>
        <p>
            To compare the sizes, I wrote out essentially the same data for each.
            Each write includes one Course object with 5 Person objects, and one
            Phone object.  The definitions for each of these types can be
            seen in the thrift file listed above.
            To capture the file sizes, I used the following techniques:
        </p>
        <table width="100%">
<tr>
<td align="center" colspan="1" rowspan="1">
        <table class="data">
            <tr>
                <th colspan="1" rowspan="1">Method</th>
                <th colspan="1" rowspan="1">Capture Technique</th>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">Thrift</td>
                <td colspan="1" rowspan="1">Custom client that forked the returning input stream to a file.</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">Protocol Buffers</td>
                <td colspan="1" rowspan="1">Stream to a file.  Excludes messaging overhead.</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">RMI</td>
                <td colspan="1" rowspan="1">Object serialization of the response.  Excludes messaging overhead.</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">REST</td>
                <td colspan="1" rowspan="1">Use wget from the commandline redirecting the response to a file.</td>
            </tr>
        </table>
        </td>
</tr>
</table>
        <p>
            The chart and table below show the results.  Sizes are in bytes.
            None of the sizes include TCP/IP overhead.
        </p>
        <table width="100%">
<tr>
<td align="center" colspan="1" rowspan="1">
<table class="data">
<tr>
<td colspan="1" rowspan="1">
            <img moz-do-not-send="true" src="http://www.ociweb.com/jnb/jnbJun2009_size_comparison.png" alt="Size Comparison Chart"/>
        </td>
</tr>
</table>
</td>
</tr>
</table>
        <table width="100%">
<tr>
<td align="center" colspan="1" rowspan="1">
        <table class="data">
            <tr>
                <th colspan="1" rowspan="1">Method</th>
                <th colspan="1" rowspan="1">Size*</th>
                <th colspan="1" rowspan="1">% Larger than TCompactProtocol</th>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">Thrift &mdash; TCompactProtocol</td>
                <td colspan="1" rowspan="1">278</td>
                <td colspan="1" rowspan="1">N/A</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">Thrift &mdash; TBinaryProtocol</td>
                <td colspan="1" rowspan="1">460</td>
                <td colspan="1" rowspan="1">65.47%</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">Protocol Buffers**</td>
                <td colspan="1" rowspan="1">250</td>
                <td colspan="1" rowspan="1">-10.07%</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">RMI (using Object Serialization for estimate)**</td>
                <td colspan="1" rowspan="1">905</td>
                <td colspan="1" rowspan="1">225.54%</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">REST &mdash; JSON</td>
                <td colspan="1" rowspan="1">559</td>
                <td colspan="1" rowspan="1">101.08%</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">REST &mdash; XML</td>
                <td colspan="1" rowspan="1">836</td>
                <td colspan="1" rowspan="1">200.72%</td>
            </tr>
        </table>
        </td>
</tr>
</table>
        <p>
            *Smaller is better.<br/>
            ** Excludes messaging overhead.  Includes only transported objects.
        </p>
        <p>
            Thrift has a clear advantage in the size of its payload particularly
            compared to RMI and XML-based REST.  Protocol Buffers from Google
            is effectively the same given that the Protocol Buffers number
            excludes messaging overhead.
        </p>
        <h3>Runtime Performance</h3>
        <p>
            To compare the runtime performance of Thrift, I created the following
            scenario:
        </p>
        <p>
<b>Test Scenario</b>
</p>
        <ul>
            <li>Query the list of Course numbers.</li>
            <li>Fetch the course for each course number.</li>
        </ul>
        <p>
            This scenario is executed 10,000 times.  The tests were run on the
            following systems:
        </p>
        <table width="100%">
        <tr>
<td align="center" colspan="1" rowspan="1">
<b>Server</b>
</td>
<td colspan="1" rowspan="1"/>
        <td align="center" colspan="1" rowspan="1">
<b>Client</b>
</td>
</tr>
        <tr>
<td align="center" colspan="1" rowspan="1">
        <table class="data">
            <tr>
                <td class="rowheader" colspan="1" rowspan="1">Operating System</td>
                <td colspan="1" rowspan="1">Ubuntu&reg; Linux&reg; 8.04 (hardy)</td>
            </tr>
            <tr>
                <td class="rowheader" colspan="1" rowspan="1">CPU</td>
                <td colspan="1" rowspan="1">Intel&reg; Core&trade; 2 T5500 @ 1.66 GHz</td>
            </tr>
            <tr>
                <td class="rowheader" colspan="1" rowspan="1">Memory</td>
                <td colspan="1" rowspan="1">2GiB</td>
            </tr>
            <tr>
                <td class="rowheader" colspan="1" rowspan="1">Cores</td>
                <td>2</td>
            </tr>
            <tr>
                <td class="rowheader" colspan="1" rowspan="1">Window System</td>
                <td colspan="1" rowspan="1">Shutdown - To avoid any unnecessary spikes from other
                processes during execution.</td>
            </tr>
            <tr>
                <td class="rowheader" colspan="1" rowspan="1">Java Version</td>
                <td colspan="1" rowspan="1">Sun&reg; Java&trade; SE Runtime Environment (build 1.6.0_14-b08)</td>
            </tr>
        </table>
        </td>
<td colspan="1" rowspan="1">&nbsp;&nbsp;</td>
<td align="center" colspan="1" rowspan="1">
        <table class="data">
            <tr>
                <td class="rowheader" colspan="1" rowspan="1">Operating System</td>
                <td colspan="1" rowspan="1">Ubuntu&reg; Linux&reg; 8.04 (hardy)</td>
            </tr>
            <tr>
                <td class="rowheader" colspan="1" rowspan="1">CPU</td>
                <td colspan="1" rowspan="1">Intel&reg; Pentium&trade; 4 @ 2.40 GHz</td>
            </tr>
            <tr>
                <td class="rowheader" colspan="1" rowspan="1">Memory</td>
                <td colspan="1" rowspan="1">1GiB</td>
            </tr>
            <tr>
                <td class="rowheader" colspan="1" rowspan="1">Cores</td>
                <td>1</td>
            </tr>
            <tr>
                <td class="rowheader" colspan="1" rowspan="1">Window System</td>
                <td colspan="1" rowspan="1">Shutdown - To avoid any unnecessary spikes from other
                processes during execution.</td>
            </tr>
            <tr>
                <td class="rowheader" colspan="1" rowspan="1">Java Version</td>
                <td colspan="1" rowspan="1">Sun&reg; Java&trade; SE Runtime Environment (build 1.6.0_14-b08)</td>
            </tr>
        </table>
        </td>
</tr>
</table>
        <p>
            The following table describes each test run:
        </p>
        <table width="100%">
<tr>
<td align="center" colspan="1" rowspan="1">
        <table class="data">
            <tr>
                <th colspan="1" rowspan="1">Method</th>
                <th colspan="1" rowspan="1">Description</th>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">Thrift</td>
                <td colspan="1" rowspan="1">Complete Thrift stack</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">Protocol Buffers*</td>
                <td colspan="1" rowspan="1">Custom server using normal, blocking socket I/O.</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">RMI</td>
                <td colspan="1" rowspan="1">Standard RMI</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">REST &mdash; XML &amp; JSON</td>
                <td colspan="1" rowspan="1">Jersey running inside a Jetty server.</td>
            </tr>
        </table>
        </td>
</tr>
</table>
        <p>
            *Since Protocol Buffers does not include a services infrastructure
            (unlike Thrift), I wrote my own server for this article.
        </p>
        <p>The chart and table below summarize the results.  All times are in seconds.</p>
        <table width="100%">
<tr>
<td align="center" colspan="1" rowspan="1">
<table class="data">
<tr>
<td colspan="1" rowspan="1">
            <img moz-do-not-send="true" src="http://www.ociweb.com/jnb/jnbJun2009_exec_perc.png" alt="Server CPU % Comparison Chart"/>
        </td>
</tr>
</table>
</td>
</tr>
</table>
        <table width="100%">
<tr>
<td align="center" colspan="1" rowspan="1">
<table class="data">
<tr>
<td colspan="1" rowspan="1">
            <img moz-do-not-send="true" src="http://www.ociweb.com/jnb/jnbJun2009_exec_time.png" alt="Execution Time Comparison Chart"/>
        </td>
</tr>
</table>
</td>
</tr>
</table>
        <table width="100%">
<tr>
<td align="center" colspan="1" rowspan="1">
        <table class="data">
            <tr>
                <th colspan="1" rowspan="1"/>
                <th colspan="1" rowspan="1">Server CPU %</th>
                <th colspan="1" rowspan="1">Avg Client CPU %</th>
                <th colspan="1" rowspan="1">Avg Wall Time</th>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">REST &mdash; XML</td>
                <td colspan="1" rowspan="1">12.00%</td>
                <td colspan="1" rowspan="1">80.75%</td>
                <td colspan="1" rowspan="1">05:27.45</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">REST &mdash; JSON</td>
                <td colspan="1" rowspan="1">20.00%</td>
                <td colspan="1" rowspan="1">75.00%</td>
                <td colspan="1" rowspan="1">04:44.83</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">RMI</td>
                <td colspan="1" rowspan="1">16.00%</td>
                <td colspan="1" rowspan="1">46.50%</td>
                <td colspan="1" rowspan="1">02:14.54</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">Protocol Buffers</td>
                <td colspan="1" rowspan="1">30.00%</td>
                <td colspan="1" rowspan="1">37.75%</td>
                <td colspan="1" rowspan="1">01:19.48</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">Thrift &mdash; TBinaryProtocol</td>
                <td colspan="1" rowspan="1">33.00%</td>
                <td colspan="1" rowspan="1">21.00%</td>
                <td colspan="1" rowspan="1">01:13.65</td>
            </tr>
            <tr>
                <td colspan="1" rowspan="1">Thrift &mdash; TCompactProtocol</td>
                <td colspan="1" rowspan="1">30.00%</td>
                <td colspan="1" rowspan="1">22.50%</td>
                <td colspan="1" rowspan="1">01:05.12</td>
            </tr>
        </table>
        </td>
</tr>
</table>
        <p>
            *Average Time excludes the first run in order to account for server
            warm-up.  Smaller numbers are better.
        </p>
        <p>
            The tests yielded some interesting observations.  In terms of wall
            time Thrift clearly out-performed REST and RMI.  In fact, TCompactProtocol
            took less than 20% of the time it took REST-XML to transmit the
            same data.
            The clear dominance of the binary protocols should not be too
            surprising, as binary data transmission is well-known to have higher
            performance than text-based protocols.  RMI in fact significantly
            out-performed JSON-based REST in wall time, despite its significantly larger
            payload size (61.9% larger).
        </p>
        <p>
            The CPU percentages yielded some interesting numbers.  While the
            Thrift and Protocol Buffers servers had the highest server CPU
            percentages, the REST clients had the highest CPU percentages
            of the clients.  For whatever reason Thrift and REST disproportionately
            place their CPU loads on their clients and servers.
            Protocol Buffers balanced its load most evenly between client and
            server, but then again this was a simple quick hand-rolled server
            that I wrote for this article.
            While I did not have time to analyze the cause of the
            CPU load, the Thrift and Protocol Buffers examples needed to do
            manual conversion of objects between what is transmitted and what
            is used.  The RMI and REST implementations required no such
            object conversion.  This extra bit of work may account for the
            additional CPU utilization on the Thrift and Protocol Buffers servers.
        </p>
        <p>
            This test basically just covered throughput of each server.
            Another useful test would have been too test how each server
            handled multiple concurrent connections of shorter duration.  There
            was insufficient time to complete a concurrent test for this article,
            however.
        </p>
        <p>
            Given the poor performance of REST, there may certainly
            be higher performing servlet containers than Jetty that could be
            used as part of this test.
            Jetty was merely chosen because of its relative ease in implementation
            and ease in bundling for download of the sample code used in this
            article.
            Doing some quick searches, I found
            one performance comparison that showed Apache Tomcat to be faster than
            Jetty, and another that showed them at parity.  Neither study showed
            anywhere near a performance difference to make up for the wall
            time performance of the binary protocols.
        </p>
        <p>
            All of these technologies are roughly equivalent in the amount of
            coding complexity required to make them work.  This excludes
            Protocol Buffers of course, as it contains no services infrastructure.
            It should also be
            noted that Thrift generates all the code you need for a client or
            server for each language it supports.  Java was the server of choice
            in this article, but other languages could be used if they are better
            suited - one of the main reasons Thrift was developed in the first
            place.
            That being said, I found many of the implementations incomplete.  As
            mentioned previously, the Python implmentation for instance only
            had the TBinaryProtocol implemented.
        </p>
        <h2 id="conclusion">Conclusion</h2>
        <p>
            Thrift is a powerful library for creating high-performance services
            that can be called from multiple languages.  If your application has
            a need for multiple languages to communicate where speed is a
            concern and your clients and servers are co-located, Thrift may well
            be the choice for you.  Thrift might also
            make a good choice for IPC on a single machine where speed and/or
            interoperability are a concern.
        </p>
        <p>
            Thrift was designed for use where clients and servers are co-located,
            as in a data center.  If you consider using Thrift in environments
            where client and server are not co-located, you should expect to
            encounter some challenges.  In particular, the aforementioned
            issue with asynchronous calls, as well as lack of security are
            likely to pose challenges.
            While the security issue may be solved by a new transport, the
            issue with asynchronous calls will likely require work in the
            core areas of Thrift.  Plus, since Thrift supports numerous
            language bindings, you will likely need to make changes for
            each language you are using.
        </p>
        <p>
            If the composite service work-around will not work for you, the
            server-per-service limitation in Thrift may pose a problem in some
            deployment scenarios.  For instance, if the Thrift services are on
            one side of a firewall and the client's are on the other, some data
            centers may have a problem with opening up too many ports.
        </p>
        <h2>References</h2>
        <ul>
            <li>Thrift Home -
                <a href="http://incubator.apache.org/thrift" shape="rect">http://incubator.apache.org/thrift</a>
            </li>
            <li>Thrift Wiki -
                <a href="http://wiki.apache.org/thrift" shape="rect">http://wiki.apache.org/thrift</a>
            </li>
            <li>Thrift Installation -
                <a href="http://wiki.apache.org/thrift/ThriftInstallation" shape="rect">http://wiki.apache.org/thrift/ThriftInstallation</a>
            </li>
            <li>Thrift Installation (Win32)-
                <a href="http://wiki.apache.org/thrift/ThriftInstallationWin32" shape="rect">http://wiki.apache.org/thrift/ThriftInstallationWin32</a>
            </li>
            <li>Wikipedia Page on Variable-Length Quantity(VLQ) -
                <a href="http://en.wikipedia.org/wiki/Variable_length_unsigned_integer" shape="rect">http://en.wikipedia.org/wiki/Variable_length_unsigned_integer</a>
            </li>
            <li>Protocol Buffers -
                <a href="http://code.google.com/p/protobuf/" shape="rect">http://code.google.com/p/protobuf/</a>
            </li>
            <li>RESTful Web Services -
                <a href="http://java.sun.com/developer/technicalArticles/WebServices/restful/" shape="rect">http://java.sun.com/developer/technicalArticles/WebServices/restful/</a>
            </li>
            <li>Remote Method Invocation Home -
                <a href="http://java.sun.com/javase/technologies/core/basic/rmi/index.jsp" shape="rect">http://java.sun.com/javase/technologies/core/basic/rmi/index.jsp</a>
            </li>
            <li>Full source for this article -
                <a href="http://www.ociweb.com/jnb/jnbJun2009Source.zip" shape="rect">http://www.ociweb.com/jnb/jnbJun2009Source.zip</a>
            </li>
        </ul>

<hr class="June"/>
<h2 id="ocieducationalservices">OCI Educational Services</h2>

<p>
    OCI is the leading provider of Object Oriented technology training in the
    Midwest. More than 3,000 students participated in our training program over
    the last 12 months. Targeted toward Software Engineers and the development
    community, our extensive program of
    <a href="http://www.ociweb.com/education/course-catalog">over 50
        hands-on workshops</a> is delivered to corporations and individuals
    throughout the U.S. and internationally. OCI's Educational Services include
    <a href="http://www.ociweb.com/training/private">Group
        Training</a> events and
    <a href="http://www.ociweb.com/training/public"> Open
        Enrollment classes</a>.
</p>

<p>
    For further information regarding OCI's Educational Services programs,
    please visit our <a href="http://www.ociweb.com/education">Educational
    Services</a> section on this site or contact us at <a
        href="mailto:training@ociweb.com">training@ociweb.com</a>.
</p>

<h2 id="ociservices">OCI Services</h2>

<p>
	In order to help the client succeed, OCI offers a broad spectrum of services and solutions
	to our customers.  Which services and solutions are appropriate for a particular client 
	depend on the individual needs of the client, the details of the engagement, and the nature
	of the problem space.
</p>

<p>
	OCI offers a variety of knowledge transfer services that include training, mentoring, and consulting.
	These can be used to quickly bring your existing staff up to speed on specific technologies and new
	products as well as entirely new software development approaches.
</p>

<p>
	OCI uses and supports many different <a href="http://www.ociweb.com/open_source">open source</a>
	products and continually evaluates and adopts new products.  For those products that we have developed 
	or have become a core part of our business, we offer first class commercial support as well as 
	<a href="http://www.ociweb.com/solutions-services">services</a>	tailored to their adoption and deployment.
</p>

<p>
	We are able to offer support for the customer in all phases of their software development, 
	<a href="http://www.ociweb.com/delivery-models">delivery</a>, and 
	deployment.  Starting with <a href="http://www.ociweb.com/architecture">Software Architecture support</a>, 
	we can help define the system, architecture, and associated development plan.  We staff internal development 
	centers that have the ability to deliver Turnkey solutions to your organization.  We can also help augment 
	your in-house development with <a href="http://www.ociweb.com/advantage-consulting">Advantage IT Staffing solutions</a>.
</p>

<p>
	OCI helps organizations to <a href="http://www.ociweb.com/integration">integrate existing software</a>
	systems as well as help architect and develop integrated "Systems of Systems".
</p>

<table border="0" width="100%">
    <tr>
        <td><a href="http://www.youtube.com/ocitv">
            <img moz-do-not-send="true" alt="Fun People Doing Serious Software Engineering"
                 height="87" src="http://sett.ociweb.com/sett/settimages/ocitv.jpg"
                 width="80"/></a>
        </td>
    </tr>
</table>

<hr class="June"/>
<p class="footer">
<strong>Object Computing, Inc.</strong> is located in  
            St. Louis, MO and a Member of the Object Management
            Group, OMG. OCI specializes in distributed computing using
            object-oriented and web-enabled technologies and provides
            <a href="http://www.ociweb.com/consulting/index.html">Consulting</a>,
            <a href="http://www.ociweb.com/education/index.html">Education</a>
            and
            <a href="http://www.ociweb.com/product/index.html">Product Development</a>
            services to clients nation-wide. For more information contact us in
            St. Louis, MO (314)579-0066, Tempe, AZ (480)752-0042 or email
            <a href="mailto:info@ociweb.com">info@ociweb.com</a>.
        </p>
<p class="footer">
            Inquiries regarding
            <a class="career" href="http://www.ociweb.com/careers/index.html">Career Opportunities</a>
            can be directed to: <a href="mailto:hr@ociweb.com">hr@ociweb.com</a>.
        </p>
<p class="footer">
            The <em>
<strong>Software Engineering Tech Trends</strong>
</em>
            is a monthly newsletter. The purpose and intent of this publication is to
			partner with clients in developing solutions for their most demanding mission critical
			systems, by leveraging our deep experience in software and systems engineering. We promote
			non-proprietary, standards-based solutions that afford our clients greater control and 
			broader choice. Knowledge transfer is a fundamental aspect of services we offer our customers.
			We tailor our engagements to meet customer needs. We foster the professional growth of our 
			employees and reward excellence.

                To
                <a href="mailto:sett-join@ociweb.com">subscribe</a>
                or
                <a href="mailto:sett-leave@ociweb.com">unsubscribe</a>
</p>
<p class="footer">
            Copyright
            &copy;2008-2011.
            Object Computing, Inc. All rights reserved.<br/>
<br/>Java and all
            Java-based marks are trademarks or registered trademarks of Oracle Corporation.<br/>
<br/>
            .NET, C#, and .NET-based marks are trademarks or registered trademarks of Microsoft
            Corporation.
        </p>
<div class="quicklinks">
<a href="#top">Top</a>
</div>
<p/>
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr>
<td valign="bottom">
<img moz-do-not-send="true" alt="" src="http://www.ociweb.com/sett/settimages/valid-css2.png" width="88" height="31"/>
</td>
</tr>
</table>

</body>
</html>
